---
title: "Parte 02 - CÁLCULO DE LPI"
output:
  html_document:
    df_print: paged
  html_notebook: default
  word_document: default
---

Script para cálculo do LPI baseado nas instruções disponíveis [neste link](https://github.com/Zoological-Society-of-London/rlpi).

Função prepara dados do icmbio e chama funções do pacote `rlpi`

**Em fase de TESTE**

Adaptação: Elildo Carvalho Jr, ICMBio/CENAP e Fernando Lima, Algoritmo

```{r pacotes, include=FALSE}
library(here)
library(tidyverse)
library(dplyr)
install.packages("rlpi")
```

### CÁLCULO DE LPI

Carregar função para cálculo

```{r}
source(here("bin", "lpi_icmbio.R"))
```

Carregar dados. O arquivo `dadosICMBio_2014a2019.rds` deve ser gerado na etapa anterior através de `part01-fixRawData.Rmd`

```{r}
mydata <- readRDS(here("data", "dadosICMBio_2014a2019.rds"))
```

Correção de taxonomia

-   Correção de nomes científicos

-   Exclusão de identificações imprecisas

-   Atualizar campo identificador `populacao`

```{r}
mydata <- mydata %>%
#CORREÇÃO DE NOMES CIENTÍFICOS
mutate(binomial = case_when(
  binomial == "bradypus variegatus" ~ "Bradypus variegatus",
  binomial == "Puma yagouaroundi" ~ "Herpailurus yagouaroundi",
  binomial == "Lontra longicaudata" ~ "Lontra longicaudis",
  binomial == "Speothus venaticus" ~ "Speothos venaticus",
  
  TRUE ~ binomial
  )
  ) %>%
#REMOVER IDENTIFICAÇÕES IMPRECISAS
  filter(! binomial  %in% c(
    NA,
    "E",
    "Tinamidae",
    "Cracidae",
    "Sciuridae",
    "Callitrichidae",
    "Pitheciidae",
    "Atelidae",
    "Cebidae",
    "Primates",
    "Felidae",
    "Bradypodidae",
    "Cervidae",
    "Tayassuidae",
    "Dasyprocta cf. fuliginosa",
    "Procyonidae"
    )
    ) %>%
#REMOVER *.sp
  filter(! grepl('sp.', binomial))
#ATUALIZAR IDENTIFICADOR DE POPULAÇÕES
mydata$populacao = paste(mydata$binomial, mydata$cnuc, sep ="_")
mydata$populacao = str_replace(mydata$populacao, " ", "_")
mydata$esforco= mydata$esforco/1000
```

Contagem de Unidades de Conservação

```{r}
ucs <- mydata %>%
  group_by(nome_UC) %>%
  count()
```

Contagem de espécies

```{r}
sp <- mydata %>%
  group_by(binomial) %>%
  count() %>%
  arrange(desc(n))
```

Contagem de populações

```{r}
population <- mydata %>%
  group_by(populacao, cnuc) %>%
  count() %>%
  arrange(desc(n)) %>%
  filter()
```

Cálculo de esforço

```{r}
effort <- mydata %>%
#AGRUPAR PODE UNIDADE DE CONSERVAÇÃO E ANO
  group_by(cnuc, ano) %>%
#SOMAR ESFORÇO ANUAL POR UNIDADE DE CONSERVAÇÃO
  summarize(sum(esforco, na.rm = TRUE)) %>%
#RENOMEAR COLUNA RESULTANTE
  rename(effort = "sum(esforco, na.rm = TRUE)") %>%
#FILTRAR PELO QUE SERIA O ESFORÇO MÍNIMO
  filter(effort > 149)
```

### Seleção por critérios

Selecionar UCs Seleção de UCs com mais de 1 ano de amostragem e mais de 149 km de esforço anual.

```{r}
ucs_selecionadas <- effort %>%
  group_by(cnuc) %>% 
  count() %>%
  filter(n > 1) %>%
  pull(cnuc)
ucs_selecionadas
```

Filtrar

Filtrar dados gerais mantendo somente UCs selecionadas

```{r}
mydata <- mydata %>%
  filter(cnuc %in% ucs_selecionadas)
mydata
```

Esforço anual em km

```{r}
esforco_anual <- mydata %>%
  group_by(cnuc, ano) %>%
  summarize(esforco = sum(esforco, na.rm = TRUE))
```

Esforço anual em formato *wide* (QPEHE)

```{r}
esforco_anual_wide <- esforco_anual %>%
  pivot_wider(names_from = ano, values_from = esforco) %>%
  select(cnuc,
         `2014`,
         `2015`,
         `2016`,
         `2017`,
         `2018`,
         `2019`
         ) %>%
  ungroup()
```

Número de registros anuais

```{r}
n_registros <- mydata %>%
  group_by(cnuc, ano, populacao) %>%
  count() #%>%
 # mutate(n = as.numeric(n))
```

Número de registros anuais em formato *wide* (QPEHE)

```{r}
n_registros_wide <- n_registros %>%
  pivot_wider(names_from = ano, values_from = n) %>%
  select(cnuc,
         populacao,
         `2014`,
         `2015`,
         `2016`,
         `2017`,
         `2018`,
         `2019`
         ) %>%
  replace(is.na(.), 0) %>%
  ungroup()
n_registros_wide
```

### Taxa de encontro anual

Estimativa de abundância relativa (número de registros por esforço). Neste caso *NAs* devem ser mantidos! Vai entender...

```{r}
taxas_anuais <- data.frame(n_registros_wide)
esforcos_anuais <- data.frame(esforco_anual_wide)
for(i in 1:nrow(taxas_anuais)) {
  cnuc_temp <- taxas_anuais[i, "cnuc"]
  esforco_temp <- esforcos_anuais %>% filter(cnuc == cnuc_temp) %>% select(-cnuc)
  taxas_anuais[i, 3:8] <- round(taxas_anuais[i, 3:8]/esforco_temp, 3)
}
taxas_anuais <- as_tibble(taxas_anuais)
taxas_anuais %>%
  print(n=Inf)
```

Selecionar populações com taxa de avistamento média acima de 0.1 (1 ind/10km)

```{r}
taxas_anuais <- taxas_anuais %>%
  mutate(media = rowMeans(.[,3:8])) %>%
  filter(media > 0.1) %>%
  select(-media)

print(taxas_anuais, n=Inf)
```